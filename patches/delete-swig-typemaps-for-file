Bottom: c48fe11b652dbc21f9cc738128227ee4cf651730
Top:    dea4319c6571f7b4f341144b722b6faf7d56ba33
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-09-19 17:50:44 -0700

delete SWIG typemaps for FILE*


---
diff --git a/lldb/include/lldb/Host/File.h b/lldb/include/lldb/Host/File.h
index 3128a8540b1..b1133bcdd6f 100644
--- a/lldb/include/lldb/Host/File.h
+++ b/lldb/include/lldb/Host/File.h
@@ -126,20 +126,6 @@ public:
   ///     ENOTSUP, success, or another error.
   virtual Status GetFileSpec(FileSpec &file_spec) const;
 
-  /// DEPRECATED! Extract the underlying FILE* and reset this File without closing it.
-  ///
-  /// This is only here to support legacy SB interfaces that need to convert scripting
-  /// language objects into FILE* streams.   That conversion is inherently sketchy and
-  /// doing so may cause the stream to be leaked.
-  ///
-  /// After calling this the File will be reset to its original state.  It will be
-  /// invalid and it will not hold on to any resources.
-  ///
-  /// \return
-  ///     The underlying FILE* stream from this File, if one exists and can be extracted,
-  ///     nullptr otherwise.
-  virtual FILE *TakeStreamAndClear();
-
   /// Get underlying OS file descriptor for this file, or kInvalidDescriptor.
   /// If the descriptor is valid, then it may be used directly for I/O
   /// However, the File may also perform it's own buffering, so avoid using
@@ -402,7 +388,6 @@ public:
   Status Close() override;
   WaitableHandle GetWaitableHandle() override;
   Status GetFileSpec(FileSpec &file_spec) const override;
-  FILE *TakeStreamAndClear() override;
   int GetDescriptor() const override;
   FILE *GetStream() override;
   off_t SeekFromStart(off_t offset, Status *error_ptr = nullptr) override;
diff --git a/lldb/scripts/Python/python-typemaps.swig b/lldb/scripts/Python/python-typemaps.swig
index b9389022512..8ff178bc5e5 100644
--- a/lldb/scripts/Python/python-typemaps.swig
+++ b/lldb/scripts/Python/python-typemaps.swig
@@ -451,74 +451,6 @@ bool SetNumberFromPyObject<double>(double &number, PyObject *obj) {
   }
 }
 
-// FIXME both of these paths wind up calling fdopen() with no provision for ever calling
-// fclose() on the result.  SB interfaces that use FILE* should be deprecated for scripting
-// use and this typemap should eventually be removed.
-%typemap(in) FILE * {
-   using namespace lldb_private;
-   if ($input == Py_None)
-      $1 = nullptr;
-   else if (!lldb_private::PythonFile::Check($input)) {
-      int fd = PyObject_AsFileDescriptor($input);
-      if (fd < 0 || PyErr_Occurred())
-        return nullptr;
-      PythonObject py_input(PyRefType::Borrowed, $input);
-      PythonString py_mode = py_input.GetAttributeValue("mode").AsType<PythonString>();
-      if (!py_mode.IsValid() || PyErr_Occurred())
-        return nullptr;
-        FILE *f;
-        if ((f = fdopen(fd, py_mode.GetString().str().c_str())))
-          $1 = f;
-        else {
-          PyErr_SetString(PyExc_TypeError, strerror(errno));
-          return nullptr;
-        }
-   }
-   else
-   {
-      PythonFile py_file(PyRefType::Borrowed, $input);
-      lldb::FileUP file = py_file.GetUnderlyingFile();
-      if (!file)
-         return nullptr;
-      $1 = file->TakeStreamAndClear();
-    }
-}
-
-%typemap(out) FILE * {
-   // TODO: This is gross. We should find a way to fetch the mode flags from the
-   // lldb_private::File object.
-   char mode[4] = {0};
-%#ifdef __APPLE__
-   int i = 0;
-   if ($1)
-   {
-       short flags = $1->_flags;
-
-       if (flags & __SRD)
-          mode[i++] = 'r';
-       else if (flags & __SWR)
-          mode[i++] = 'w';
-       else // if (flags & __SRW)
-          mode[i++] = 'a';
-    }
-%#else
-   // There's no portable way to get the mode here. We just return a mode which
-   // permits both reads and writes and count on the operating system to return
-   // an error when an invalid operation is attempted.
-   mode[0] = 'r';
-   mode[1] = '+';
-%#endif
-   using namespace lldb_private;
-   NativeFile file($1, false);
-   PythonFile py_file(file, mode);
-   $result = py_file.release();
-   if (!$result)
-   {
-       $result = Py_None;
-       Py_INCREF(Py_None);
-   }
-}
-
 %typemap(in) (const char* string, int len) {
     using namespace lldb_private;
     if ($input == Py_None)
diff --git a/lldb/source/Host/common/File.cpp b/lldb/source/Host/common/File.cpp
index 4d9e2c2cd7d..2da8fd3e0cf 100644
--- a/lldb/source/Host/common/File.cpp
+++ b/lldb/source/Host/common/File.cpp
@@ -105,8 +105,6 @@ Status File::GetFileSpec(FileSpec &file_spec) const {
   return std::error_code(ENOTSUP, std::system_category());
 }
 
-FILE *File::TakeStreamAndClear() { return nullptr; }
-
 int File::GetDescriptor() const { return kInvalidDescriptor; }
 
 FILE *File::GetStream() { return nullptr; }
@@ -315,18 +313,6 @@ Status NativeFile::Close() {
   return error;
 }
 
-FILE *NativeFile::TakeStreamAndClear() {
-  FILE *stream = GetStream();
-  m_stream = NULL;
-  m_descriptor = kInvalidDescriptor;
-  m_options = 0;
-  m_own_stream = false;
-  m_own_descriptor = false;
-  m_is_interactive = m_supports_colors = m_is_real_terminal =
-      eLazyBoolCalculate;
-  return stream;
-}
-
 Status NativeFile::GetFileSpec(FileSpec &file_spec) const {
   Status error;
 #ifdef F_GETPATH
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index d4f485fa6a3..4d6b2b6f644 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -1092,21 +1092,6 @@ Expected<PythonFile> PythonFile::FromFile(File &file, const char *mode) {
   return Take<PythonFile>(file_obj);
 }
 
-FileUP PythonFile::GetUnderlyingFile() const {
-  if (!IsValid())
-    return nullptr;
-
-  // We don't own the file descriptor returned by this function, make sure the
-  // File object knows about that.
-  PythonString py_mode = GetAttributeValue("mode").AsType<PythonString>();
-  auto options = File::GetOptionsFromMode(py_mode.GetString());
-  auto file = std::unique_ptr<File>(
-      new NativeFile(PyObject_AsFileDescriptor(m_py_obj), options, false));
-  if (!file->IsValid())
-    return nullptr;
-  return file;
-}
-
 namespace {
 class GIL {
 public:
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
index fc601679326..7852cb5c9b4 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
@@ -681,8 +681,6 @@ public:
     }
   }
 
-  lldb::FileUP GetUnderlyingFile() const;
-
   llvm::Expected<lldb::FileSP> ConvertToFile(bool borrowed = false);
   llvm::Expected<lldb::FileSP>
   ConvertToFileForcingUseOfScriptingIOMethods(bool borrowed = false);
