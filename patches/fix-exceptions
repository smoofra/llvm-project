Bottom: 99883517fd4feec84da5697eeaa8ef324363c218
Top:    7443f8bb7c6385824f0d631a395476dee5644618
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-07 13:30:14 -0700

fix-exceptions


---
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index 658e43e8941..1fdd699d46d 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -30,18 +30,19 @@
 using namespace lldb_private;
 using namespace lldb;
 using namespace lldb_private::python;
+using llvm::Error;
+using llvm::Expected;
 
 namespace lldb_private {
 namespace python {
-// This is why C++ needs monads.
-Expected<bool> AsBool(Expected<PythonObject> &&obj) {
+template <> Expected<bool> As<bool>(Expected<PythonObject> &&obj) {
   if (obj) {
     return obj.get().IsTrue();
   } else {
     return obj.takeError();
   }
 }
-Expected<long long> AsLongLong(Expected<PythonObject> &&obj) {
+template <> Expected<long long> As<long long>(Expected<PythonObject> &&obj) {
   if (obj) {
     return obj.get().AsLongLong();
   } else {
@@ -358,11 +359,7 @@ Expected<PythonString> PythonString::FromUTF8(llvm::StringRef string) {
 #endif
   if (!str)
     return llvm::make_error<PythonException>();
-  return AssertTake<PythonString>(str);
-}
-
-Expected<PythonString> PythonString::FromUTF8(const char *string) {
-  return FromUTF8(llvm::StringRef(string));
+  return Take<PythonString>(str);
 }
 
 PythonString::PythonString(PyRefType type, PyObject *py_obj) : PythonObject() {
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
index e524b3757c3..441da3a8bfa 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
@@ -41,9 +41,6 @@
 
 namespace lldb_private {
 
-using llvm::Error;
-using llvm::Expected;
-
 class PythonObject;
 class PythonBytes;
 class PythonString;
@@ -101,39 +98,65 @@ namespace python {
 
 // Take a reference that you already own, and turn it into
 // a PythonObject.
-template <typename T> static T Take(PyObject *obj) {
-  return T(PyRefType::Owned, obj);
+//
+// Most python API methods will return a +1 reference
+// if they succeed or NULL if and only if
+// they set an exception.   Use this to collect such return
+// values, after checking for NULL.
+//
+// If T is not just PythonObject, then obj must be already be
+// checked to be of the correct type.
+template <typename T> T Take(PyObject *obj) {
+  assert(obj);
+  assert(!PyErr_Occurred());
+  T thing(PyRefType::Owned, obj);
+  assert(thing.IsValid());
+  return std::move(thing);
 }
 
 // Retain a reference you have borrowed, and turn it into
 // a PythonObject.
-template <typename T> static T Retain(PyObject *obj) {
-  return T(PyRefType::Borrowed, obj);
-}
-
-// Most python API methods will return NULL if and only if
-// they set an exception.   Use this to collect such return
-// values.
 //
-// If you pass something ohter than PythonObject as T,
-// you are NOT asserting that the thing is actually of
-// type T.   You'll get an invalid T back in that case,
-// so check if you need to.
-template <typename T> static T AssertTake(PyObject *obj) {
+// A minority of python APIs return a borrowed reference
+// instead of a +1.   They will also return NULL if and only
+// if they set an exception.   Use this to collect such return
+// values, after checking for NULL.
+//
+// If T is not just PythonObject, then obj must be already be
+// checked to be of the correct type.
+template <typename T> T Retain(PyObject *obj) {
   assert(obj);
   assert(!PyErr_Occurred());
-  T thing(PyRefType::Owned, obj);
-  return thing;
+  T thing(PyRefType::Borrowed, obj);
+  assert(thing.IsValid());
+  return std::move(thing);
 }
 
 } // namespace python
 
 enum class PyInitialValue { Invalid, Empty };
 
+template <typename T, typename Enable = void> struct PythonFormat;
+
+template <> struct PythonFormat<unsigned long long> {
+  static constexpr char format = 'K';
+  static auto get(unsigned long long value) { return value; }
+};
+
+template <> struct PythonFormat<long long> {
+  static constexpr char format = 'L';
+  static auto get(long long value) { return value; }
+};
+
+template <typename T>
+struct PythonFormat<
+    T, typename std::enable_if<std::is_base_of<PythonObject, T>::value>::type> {
+  static constexpr char format = 'O';
+  static auto get(const T &value) { return value.get(); }
+};
+
 class PythonObject {
 public:
-  operator PyObject *() const { return m_py_obj; };
-
   PythonObject() : m_py_obj(nullptr) {}
 
   PythonObject(PyRefType type, PyObject *py_obj) : m_py_obj(nullptr) {
@@ -256,7 +279,7 @@ public:
 
   bool IsAllocated() const { return IsValid() && !IsNone(); }
 
-  operator bool() const { return IsValid() && !IsNone(); }
+  explicit operator bool() const { return IsValid() && !IsNone(); }
 
   template <typename T> T AsType() const {
     if (!T::Check(m_py_obj))
@@ -267,41 +290,41 @@ public:
   StructuredData::ObjectSP CreateStructuredObject() const;
 
 protected:
-  static Error nullDeref() {
+  static llvm::Error nullDeref() {
     return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                    "A NULL PyObject* was dereferenced");
   }
-  static Error exception(const char *s = nullptr) {
+  static llvm::Error exception(const char *s = nullptr) {
     return llvm::make_error<PythonException>(s);
   }
 
 public:
-  template <typename... Args>
-  Expected<PythonObject> CallMethod(const char *name, const char *format,
-                                    Args... args) {
-    if (!m_py_obj)
-      return nullDeref();
+  template <typename... T>
+  llvm::Expected<PythonObject> CallMethod(const char *name,
+                                          const T &... t) const {
+    const char format[] = {'(', PythonFormat<T>::format..., ')', 0};
 #if PY_MAJOR_VERSION < 3
-    PyObject *obj = PyObject_CallMethod(m_py_obj, const_cast<char *>(name),
-                                        const_cast<char *>(format), args...);
+    PyObject *obj = PyObject_CallMethod(
+        m_py_obj, name, const_cast<char *>(format), PythonFormat<T>::get(t)...);
 #else
-    PyObject *obj = PyObject_CallMethod(m_py_obj, name, format, args...);
+    PyObject *obj =
+        PyObject_CallMethod(m_py_obj, name, format, PythonFormat<T>::get(t)...);
 #endif
     if (!obj)
       return exception();
-    return python::AssertTake<PythonObject>(obj);
+    return python::Take<PythonObject>(obj);
   }
 
-  Expected<PythonObject> GetAttribute(const char *name) const {
+  llvm::Expected<PythonObject> GetAttribute(const char *name) const {
     if (!m_py_obj)
       return nullDeref();
     PyObject *obj = PyObject_GetAttrString(m_py_obj, name);
     if (!obj)
       return exception();
-    return python::AssertTake<PythonObject>(obj);
+    return python::Take<PythonObject>(obj);
   }
 
-  Expected<bool> IsTrue() {
+  llvm::Expected<bool> IsTrue() {
     if (!m_py_obj)
       return nullDeref();
     int r = PyObject_IsTrue(m_py_obj);
@@ -310,7 +333,7 @@ public:
     return !!r;
   }
 
-  Expected<long long> AsLongLong() {
+  llvm::Expected<long long> AsLongLong() {
     if (!m_py_obj)
       return nullDeref();
     assert(!PyErr_Occurred());
@@ -320,10 +343,10 @@ public:
     return r;
   }
 
-  Expected<bool> IsInstance(PyObject *cls) {
-    if (!m_py_obj || !cls)
+  llvm::Expected<bool> IsInstance(const PythonObject &cls) {
+    if (!m_py_obj || !cls.IsValid())
       return nullDeref();
-    int r = PyObject_IsInstance(m_py_obj, cls);
+    int r = PyObject_IsInstance(m_py_obj, cls.get());
     if (r < 0)
       return exception();
     return !!r;
@@ -334,21 +357,24 @@ protected:
 };
 
 namespace python {
-// This is why C++ needs monads.
-Expected<bool> AsBool(Expected<PythonObject> &&obj);
-
-Expected<long long> AsLongLong(Expected<PythonObject> &&obj);
 
-template <typename T> Expected<T> AsType(Expected<PythonObject> &&obj) {
+// This is why C++ needs monads.
+template <typename T> llvm::Expected<T> As(llvm::Expected<PythonObject> &&obj) {
   if (obj) {
-    if (!T::Check(obj.get()))
+    if (!T::Check(obj.get().get()))
       return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                      "type error");
-    return T(PyRefType::Borrowed, std::move(obj.get()));
+    return T(PyRefType::Borrowed, std::move(obj.get().get()));
   } else {
     return obj.takeError();
   }
 }
+
+template <> llvm::Expected<bool> As<bool>(llvm::Expected<PythonObject> &&obj);
+
+template <>
+llvm::Expected<long long> As<long long>(llvm::Expected<PythonObject> &&obj);
+
 } // namespace python
 
 class PythonBytes : public PythonObject {
@@ -404,8 +430,7 @@ public:
 
 class PythonString : public PythonObject {
 public:
-  static Expected<PythonString> FromUTF8(llvm::StringRef string);
-  static Expected<PythonString> FromUTF8(const char *string);
+  static llvm::Expected<PythonString> FromUTF8(llvm::StringRef string);
 
   PythonString();
   explicit PythonString(llvm::StringRef string); // safe, null on error
@@ -423,7 +448,7 @@ public:
 
   llvm::StringRef GetString() const; // safe, empty string on error
 
-  Expected<llvm::StringRef> AsUTF8() const;
+  llvm::Expected<llvm::StringRef> AsUTF8() const;
 
   size_t GetSize() const;
 
@@ -673,6 +698,27 @@ public:
   std::error_code convertToErrorCode() const override;
 };
 
+// This extracts the underlying T out of an Expected<T> and returns it.
+// If the Expected is an Error instead of a T, that error will be converted
+// into a python exception, and this will return a default-constructed T.
+//
+// This is appropriate for use right at the boundary of python calling into
+// C++, such as in a SWIG typemap.   In such a context you should simply
+// check if the returned T is valid, and if it is, return a NULL back
+// to python.   This will result in the Error being raised as an exception
+// from python code's point of view.
+//
+// For example:
+// ```
+// Expected<Foo *> efoop = some_cpp_function();
+// Foo *foop = unwrapOrSetPythonException(efoop);
+// if (!foop)
+//    return NULL;
+// do_something(*foop);
+//
+// If the Error returned was itself created because a python exception was
+// raised when C++ code called into python, then the original exception
+// will be restored.   Otherwise a simple string exception will be raised.
 template <typename T> T unwrapOrSetPythonException(llvm::Expected<T> expected) {
   if (expected)
     return expected.get();
