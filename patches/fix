Bottom: 8a6bf8c67a10f7034bbc269b77f0426b3313a8b2
Top:    d1e304a7b95a76948e79fc4e1b9e85c21809ff8f
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-16 13:37:32 -0700

fix

---
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index 5adce7aba96..fdd2104dd66 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -31,6 +31,7 @@
 using namespace lldb_private;
 using namespace lldb;
 using namespace lldb_private::python;
+using llvm::cantFail;
 using llvm::Error;
 using llvm::Expected;
 
@@ -817,6 +818,30 @@ Expected<PythonCallable::ArgInfo> PythonCallable::GetInitArgInfo() const {
   return init.get().GetArgInfo();
 }
 
+#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
+static const char *get_arg_info_script = R"(
+from inspect import signature, Parameter, ismethod
+from collections import namedtuple
+ArgInfo = namedtuple('ArgInfo', ['count', 'has_varargs', 'is_bound_method'])
+def get_arg_info(f):
+    count = 0
+    varargs = False
+    for parameter in signature(f).parameters.values():
+        kind = parameter.kind
+        if kind in (Parameter.POSITIONAL_ONLY,
+                    Parameter.POSITIONAL_OR_KEYWORD):
+            count += 1
+        elif kind == Parameter.VAR_POSITIONAL:
+            varargs = True
+        elif kind in (Parameter.KEYWORD_ONLY,
+                      Parameter.KEYWORD_ONLY):
+            pass
+        else:
+            raise Exception(f'unknown parameter kind: {kind}')
+    return ArgInfo(count, varargs, ismethod(f))
+)";
+#endif
+
 Expected<PythonCallable::ArgInfo> PythonCallable::GetArgInfo() const {
   ArgInfo result = {};
   if (!IsValid())
@@ -824,28 +849,6 @@ Expected<PythonCallable::ArgInfo> PythonCallable::GetArgInfo() const {
 
 #if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
 
-  const char *script =
-      "from inspect import signature, Parameter, ismethod \n"
-      "from collections import namedtuple \n"
-      "ArgInfo = namedtuple('ArgInfo', ['count', 'has_varargs', "
-      "'is_bound_method']) \n"
-      "def get_arg_info(f): \n"
-      "    count = 0 \n"
-      "    varargs = False  \n"
-      "    for parameter in signature(f).parameters.values():  \n"
-      "        kind = parameter.kind  \n"
-      "        if kind in (Parameter.POSITIONAL_ONLY,   \n"
-      "                    Parameter.POSITIONAL_OR_KEYWORD):  \n"
-      "            count += 1  \n"
-      "        elif kind == Parameter.VAR_POSITIONAL:  \n"
-      "            varargs = True  \n"
-      "        elif kind in (Parameter.KEYWORD_ONLY,  \n"
-      "                      Parameter.KEYWORD_ONLY):  \n"
-      "            pass  \n"
-      "        else:  \n"
-      "            raise Exception(f'unknown parameter kind: {kind}')  \n"
-      "    return ArgInfo(count, varargs, ismethod(f))  \n";
-
   // this global is protected by the GIL
   static PythonCallable get_arg_info;
 
@@ -856,8 +859,8 @@ Expected<PythonCallable::ArgInfo> PythonCallable::GetArgInfo() const {
     Error error = globals.SetItem("__builtins__", builtins);
     if (error)
       return std::move(error);
-    PyObject *o =
-        PyRun_String(script, Py_file_input, globals.get(), globals.get());
+    PyObject *o = PyRun_String(get_arg_info_script, Py_file_input,
+                               globals.get(), globals.get());
     if (!o)
       return exception();
     Take<PythonObject>(o);
@@ -870,26 +873,16 @@ Expected<PythonCallable::ArgInfo> PythonCallable::GetArgInfo() const {
   Expected<PythonObject> pyarginfo = get_arg_info.Call(*this);
   if (!pyarginfo)
     return pyarginfo.takeError();
-  Expected<long long> count =
-      As<long long>(pyarginfo.get().GetAttribute("count"));
-  if (!count)
-    return count.takeError();
-  result.count = count.get();
-  Expected<bool> has_varargs =
-      As<bool>(pyarginfo.get().GetAttribute("has_varargs"));
-  if (!has_varargs)
-    return has_varargs.takeError();
-  result.has_varargs = has_varargs.get();
-  Expected<bool> is_method =
-      As<bool>(pyarginfo.get().GetAttribute("is_bound_method"));
-  if (!is_method)
-    return is_method.takeError();
-
+  result.count = cantFail(As<long long>(pyarginfo.get().GetAttribute("count")));
+  result.has_varargs =
+      cantFail(As<bool>(pyarginfo.get().GetAttribute("has_varargs")));
+  bool is_method =
+      cantFail(As<bool>(pyarginfo.get().GetAttribute("is_bound_method")));
   result.max_positional_args =
       result.has_varargs ? ArgInfo::UNBOUNDED : result.count;
 
   // FIXME emulate old broken behavior
-  if (is_method.get())
+  if (is_method)
     result.count++;
 
 #else
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
index 853e6cb5f7f..2a2d2172dfb 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
@@ -314,19 +314,20 @@ protected:
                                    "key not in dict");
   }
 
+#if PY_MAJOR_VERSION < 3
+  static char *py2_const_cast(const char *s) { return const_cast<char *>(s); }
+#else
+  static const char *py2_const_cast(const char *s) { return s; }
+#endif
+
 public:
   template <typename... T>
   llvm::Expected<PythonObject> CallMethod(const char *name,
                                           const T &... t) const {
     const char format[] = {'(', PythonFormat<T>::format..., ')', 0};
-#if PY_MAJOR_VERSION < 3
-    PyObject *obj = PyObject_CallMethod(m_py_obj, const_cast<char *>(name),
-                                        const_cast<char *>(format),
-                                        PythonFormat<T>::get(t)...);
-#else
     PyObject *obj =
-        PyObject_CallMethod(m_py_obj, name, format, PythonFormat<T>::get(t)...);
-#endif
+        PyObject_CallMethod(m_py_obj, py2_const_cast(name),
+                            py2_const_cast(format), PythonFormat<T>::get(t)...);
     if (!obj)
       return exception();
     return python::Take<PythonObject>(obj);
@@ -335,13 +336,8 @@ public:
   template <typename... T>
   llvm::Expected<PythonObject> Call(const T &... t) const {
     const char format[] = {'(', PythonFormat<T>::format..., ')', 0};
-#if PY_MAJOR_VERSION < 3
-    PyObject *obj = PyObject_CallFunction(m_py_obj, const_cast<char *>(format),
+    PyObject *obj = PyObject_CallFunction(m_py_obj, py2_const_cast(format),
                                           PythonFormat<T>::get(t)...);
-#else
-    PyObject *obj =
-        PyObject_CallFunction(m_py_obj, format, PythonFormat<T>::get(t)...);
-#endif
     if (!obj)
       return exception();
     return python::Take<PythonObject>(obj);
