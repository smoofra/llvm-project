Bottom: 878fa5d99641d8880d99e69eebedba7aea66be79
Top:    320391e09eff895944f656162aa0e4b0149e78c5
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-18 17:14:04 -0700

Refresh of no-more-reset

---
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index dca03a9d609..90b4eafcb5a 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -843,38 +843,26 @@ def get_arg_info(f):
 )";
 #endif
 
-class PythonScript {
-  const char *script;
-  const char *function_name;
-  PythonCallable function;
-
-public:
-  PythonScript(const char *script, const char *name)
-      : script(script), function_name(name), function() {}
-
-  template <typename... Args>
-  Expected<PythonObject> operator()(Args &&... args) {
-    if (!function.IsValid()) {
-      PythonDictionary globals(PyInitialValue::Empty);
-
-      auto builtins = PythonModule::BuiltinsModule();
-      Error error = globals.SetItem("__builtins__", builtins);
-      if (error)
-        return std::move(error);
-      PyObject *o =
-          PyRun_String(script, Py_file_input, globals.get(), globals.get());
-      if (!o)
-        return exception();
-      Take<PythonObject>(o);
-      auto f = As<PythonCallable>(globals.GetItem(function_name));
-      if (!f)
-        return f.takeError();
-      function = std::move(f.get());
-    }
-
-    return function.Call(std::forward<Args>(args)...);
+Error PythonScript::Init() {
+  if (!function.IsValid()) {
+    PythonDictionary globals(PyInitialValue::Empty);
+
+    auto builtins = PythonModule::BuiltinsModule();
+    Error error = globals.SetItem("__builtins__", builtins);
+    if (error)
+      return error;
+    PyObject *o =
+        PyRun_String(script, Py_file_input, globals.get(), globals.get());
+    if (!o)
+      return exception();
+    Take<PythonObject>(o);
+    auto f = As<PythonCallable>(globals.GetItem(function_name));
+    if (!f)
+      return f.takeError();
+    function = std::move(f.get());
   }
-};
+  return Error::success();
+}
 
 Expected<PythonCallable::ArgInfo> PythonCallable::GetArgInfo() const {
   ArgInfo result = {};
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
index 922a179de37..0b7ab21d521 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
@@ -750,6 +750,44 @@ llvm::Expected<PythonObject> runStringMultiLine(CStringArg string,
 
 } // namespace python
 
+/* Sometimes the best way to interact with a python interpreter is
+ * to run some python code.   You construct a PythonScript with
+ * script string and a function name, and you get a C++ callable
+ * objedct that calls the python function.
+ *
+ * Example:
+ *
+ * const char script[] = R"(
+ * def foo(x, y):
+ *    ....
+ * )";
+ *
+ * Expected<PythonObject> cpp_foo_wrapper(PythonObject x, PythonObject y) {
+ *   // global is protected by the GIL
+ *   static PythonScript foo(script, "foo")
+ *   return  foo(x, y);
+ * }
+ */
+class PythonScript {
+  const char *script;
+  const char *function_name;
+  PythonCallable function;
+
+  llvm::Error Init();
+
+public:
+  PythonScript(const char *script, const char *name)
+      : script(script), function_name(name), function() {}
+
+  template <typename... Args>
+  llvm::Expected<PythonObject> operator()(Args &&... args) {
+    llvm::Error e = Init();
+    if (e)
+      return std::move(e);
+    return function.Call(std::forward<Args>(args)...);
+  }
+};
+
 } // namespace lldb_private
 
 #endif
diff --git a/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp b/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
index c01dade4440..4cf4fd13d9f 100644
--- a/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
+++ b/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
@@ -21,6 +21,7 @@
 
 using namespace lldb_private;
 using namespace lldb_private::python;
+using llvm::Expected;
 
 class PythonDataObjectsTest : public PythonTestSuite {
 public:
@@ -771,4 +772,32 @@ bar_unbound = Foo.bar
   }
 
 #endif
+}
+
+TEST_F(PythonDataObjectsTest, TestExceptions) {
+
+  static const char script[] = R"(
+def foo():
+  return bar()
+def bar():
+  return baz()
+def baz():
+  return 1 / 0
+)";
+
+  PythonScript foo(script, "foo");
+  Expected<PythonObject> r = foo();
+
+  bool failed = !r;
+  ASSERT_TRUE(failed);
+
+  std::string backtrace;
+  llvm::handleAllErrors(r.takeError(), [&](const PythonException &E) {
+    backtrace = E.ReadBacktrace();
+  });
+
+  EXPECT_NE(backtrace.find("line 3, in foo"), std::string::npos);
+  EXPECT_NE(backtrace.find("line 5, in bar"), std::string::npos);
+  EXPECT_NE(backtrace.find("line 7, in baz"), std::string::npos);
+  EXPECT_NE(backtrace.find("ZeroDivisionError"), std::string::npos);
 }
\ No newline at end of file
