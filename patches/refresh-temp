Bottom: 42254e5d507db322f7d0b0a00ee545bc69c31d74
Top:    f6048cef3b09c8b99571d8be1adb3abf78041743
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-04 10:54:02 -0700

Refresh of SBCommandReturnObject

---
diff --git a/lldb/include/lldb/Utility/ReproducerInstrumentation.h b/lldb/include/lldb/Utility/ReproducerInstrumentation.h
index 0fe30ede6a4..850c37c5194 100644
--- a/lldb/include/lldb/Utility/ReproducerInstrumentation.h
+++ b/lldb/include/lldb/Utility/ReproducerInstrumentation.h
@@ -16,8 +16,6 @@
 #include "llvm/ADT/StringRef.h"
 #include "llvm/Support/ErrorHandling.h"
 
-#include "lldb/API/SBFile.h"
-
 #include <iostream>
 #include <map>
 #include <type_traits>
@@ -180,6 +178,10 @@ template <typename... Ts> inline std::string stringify_args(const Ts &... ts) {
   lldb_private::repro::Recorder sb_recorder(LLVM_PRETTY_FUNCTION,              \
                                             stringify_args(__VA_ARGS__));
 
+namespace lldb {
+class SBFile;
+}
+
 namespace lldb_private {
 namespace repro {
 
@@ -238,6 +240,7 @@ struct ReferenceTag {};
 struct ValueTag {};
 struct FundamentalPointerTag {};
 struct FundamentalReferenceTag {};
+struct NotImplementedTag {};
 
 /// Return the deserialization tag for the given type T.
 template <class T> struct serializer_tag { typedef ValueTag type; };
@@ -251,6 +254,9 @@ template <class T> struct serializer_tag<T &> {
                                     FundamentalReferenceTag, ReferenceTag>::type
       type;
 };
+template <> struct serializer_tag<lldb::SBFile> {
+  typedef NotImplementedTag type;
+};
 
 /// Deserializes data from a buffer. It is used to deserialize function indices
 /// to replay, their arguments and return values.
@@ -304,6 +310,11 @@ public:
   }
 
 private:
+  template <typename T> T Read(NotImplementedTag) {
+    m_buffer = m_buffer.drop_front(sizeof(T));
+    return T();
+  }
+
   template <typename T> T Read(ValueTag) {
     assert(HasData(sizeof(T)));
     T t;
@@ -355,8 +366,6 @@ private:
 /// instead of treating it as pointer.
 template <> const char *Deserializer::Deserialize<const char *>();
 template <> char *Deserializer::Deserialize<char *>();
-template <> lldb::SBFile Deserializer::Deserialize<lldb::SBFile>();
-
 
 /// Helpers to auto-synthesize function replay code. It deserializes the replay
 /// function's arguments one by one and finally calls the corresponding
diff --git a/lldb/source/API/SBFile.cpp b/lldb/source/API/SBFile.cpp
index e9e6987a8ff..628a9f8a130 100644
--- a/lldb/source/API/SBFile.cpp
+++ b/lldb/source/API/SBFile.cpp
@@ -23,6 +23,7 @@ SBFile::SBFile(FileSP file_sp) : m_opaque_sp(file_sp) {
 SBFile::SBFile() { LLDB_RECORD_CONSTRUCTOR_NO_ARGS(SBFile); }
 
 SBFile::SBFile(FILE *file, bool transfer_ownership) {
+  LLDB_RECORD_CONSTRUCTOR(SBFile, (FILE *, bool), file, transfer_ownership);
   m_opaque_sp = std::make_shared<NativeFile>(file, transfer_ownership);
 }
 
@@ -102,11 +103,21 @@ bool SBFile::operator!() const {
   return LLDB_RECORD_RESULT(!IsValid());
 }
 
+static SBFile *dummy() { return new SBFile(); }
+static SBFile *dummy(int, const char *, bool) { return new SBFile(); }
+static SBFile *dummy(FILE *, bool) { return new SBFile(); }
+
 namespace lldb_private {
 namespace repro {
+
 template <> void RegisterMethods<SBFile>(Registry &R) {
-  LLDB_REGISTER_CONSTRUCTOR(SBFile, ());
-  LLDB_REGISTER_CONSTRUCTOR(SBFile, (int, const char *, bool));
+
+  R.Register<SBFile *()>(&dummy, "", "SBFile", "SBFile", "()");
+  R.Register<SBFile *(int, const char *, bool)>(&dummy, "", "SBFile", "SBFile",
+                                                "(int, const char *, bool)");
+  R.Register<SBFile *(FILE *, bool)>(&dummy, "", "SBFile", "SBFile",
+                                     "(FILE*, bool)");
+
   LLDB_REGISTER_METHOD(lldb::SBError, SBFile, Flush, ());
   LLDB_REGISTER_METHOD_CONST(bool, SBFile, IsValid, ());
   LLDB_REGISTER_METHOD_CONST(bool, SBFile, operator bool,());
diff --git a/lldb/source/Utility/ReproducerInstrumentation.cpp b/lldb/source/Utility/ReproducerInstrumentation.cpp
index e4b838c2d64..473786ef4d3 100644
--- a/lldb/source/Utility/ReproducerInstrumentation.cpp
+++ b/lldb/source/Utility/ReproducerInstrumentation.cpp
@@ -6,7 +6,6 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "lldb/API/SBFile.h"
 #include "lldb/Utility/ReproducerInstrumentation.h"
 #include "lldb/Utility/Reproducer.h"
 
@@ -35,17 +34,6 @@ template <> const char *Deserializer::Deserialize<const char *>() {
   return str;
 }
 
-template <> lldb::SBFile Deserializer::Deserialize<lldb::SBFile>() {
-    //@JDevlieghere I'm pretty sure this is not the right thing to
-    //do, but I don't know what is!   Without this the reproducer
-    //tests read bytes out of the file, treats them as a SBFile --
-    //which is just a shared_ptr -- and start calling copy
-    //constructors on it.  Hilarity ensues.   Surprisingly
-    //just returning an invalid SBFile here seems to work.
-    m_buffer = m_buffer.drop_front(sizeof(lldb::SBFile));
-    return lldb::SBFile();
-}
-
 bool Registry::Replay(const FileSpec &file) {
   auto error_or_file = llvm::MemoryBuffer::getFile(file.GetPath());
   if (auto err = error_or_file.getError())
diff --git a/lldb/unittests/Utility/ReproducerInstrumentationTest.cpp b/lldb/unittests/Utility/ReproducerInstrumentationTest.cpp
index e62752bae8e..2a4ebac2df9 100644
--- a/lldb/unittests/Utility/ReproducerInstrumentationTest.cpp
+++ b/lldb/unittests/Utility/ReproducerInstrumentationTest.cpp
@@ -610,5 +610,3 @@ TEST(RecordReplayTest, InstrumentedBarPtr) {
 
   ValidateObjects(1, 1);
 }
-
-lldb::SBFile::SBFile() { }
