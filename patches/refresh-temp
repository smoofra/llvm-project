Bottom: d54f5c84956cea3ef0464c86690acf6e1499d3ce
Top:    c9d48d40e7da076269ea99a43eeb2bbd8a556331
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-19 16:38:45 -0700

Refresh of no-more-reset

---
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
index 935c4ec0abd..5c8acec229f 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
@@ -742,19 +742,20 @@ llvm::Expected<PythonObject> runStringMultiLine(const llvm::Twine &string,
 
 // Sometimes the best way to interact with a python interpreter is
 // to run some python code.   You construct a PythonScript with
-// script string and a function name, and you get a C++ callable
-// object that calls the python function.
+// script string.   The script assigns some function to `_function_`
+// and you get a C++ callable object that calls the python function.
 //
 // Example:
 //
 // const char script[] = R"(
 // def foo(x, y):
 //    ....
+// _function_ = foo
 // )";
 //
 // Expected<PythonObject> cpp_foo_wrapper(PythonObject x, PythonObject y) {
 //   // no need to synchronize access to this global, we already have the GIL
-//   static PythonScript foo(script, "foo")
+//   static PythonScript foo(script)
 //   return  foo(x, y);
 // }
 class PythonScript {
