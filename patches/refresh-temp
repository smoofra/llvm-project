Bottom: 0c57646f6a72be048bb5acc8e98abbada67e630f
Top:    75604501ff67092ec2c4d6e8d87f3d61cdfb0ffe
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-19 13:24:35 -0700

Refresh of no-more-reset

---
diff --git a/lldb/include/lldb/Interpreter/ScriptInterpreter.h b/lldb/include/lldb/Interpreter/ScriptInterpreter.h
index 4c58eb70349..23fadf02e59 100644
--- a/lldb/include/lldb/Interpreter/ScriptInterpreter.h
+++ b/lldb/include/lldb/Interpreter/ScriptInterpreter.h
@@ -65,9 +65,9 @@ public:
 
     bool GetSetLLDBGlobals() const { return m_set_lldb_globals; }
 
-    /* If this is true then any exceptions raised by the script will be
-     * cleared with PyErr_Clear().   If false then they will be left for
-     * the caller to clean up */
+    // If this is true then any exceptions raised by the script will be
+    // cleared with PyErr_Clear().   If false then they will be left for
+    // the caller to clean up
     bool GetMaskoutErrors() const { return m_maskout_errors; }
 
     ExecuteScriptOptions &SetEnableIO(bool enable) {
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index 6371c0d87dd..8c4ef17ef5e 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -1053,7 +1053,10 @@ def read_exception(exc_type, exc_value, tb):
   return f.getvalue()
 )";
 
-std::string PythonException::ReadBacktrace() const {
+std::string PythonException::ReadBacktrace(bool recursing) const {
+
+  if (!m_traceback)
+    return toCString();
 
   // global is protected by the GIL
   static PythonScript read_exception(read_exception_script, "read_exception");
@@ -1062,8 +1065,20 @@ std::string PythonException::ReadBacktrace() const {
       read_exception(m_exception_type, m_exception, m_traceback));
 
   if (!backtrace) {
-    llvm::consumeError(backtrace.takeError());
-    return "backtrace unavailable";
+    Twine message =
+        Twine(toCString()) + "\n" +
+        "Traceback unavailble, an error occurred while reading it:\n";
+    if (recursing)
+      return (message + llvm::toString(backtrace.takeError())).str();
+
+    std::string backtrace2;
+    Error error =
+        llvm::handleErrors(backtrace.takeError(), [&](PythonException &E) {
+          backtrace2 = E.ReadBacktrace(true);
+        });
+    if (error)
+      backtrace2 = llvm::toString(std::move(error));
+    return (message + backtrace2).str();
   }
 
   return std::move(backtrace.get());
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
index 099a518730c..9195aa89635 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
@@ -697,7 +697,7 @@ public:
   void log(llvm::raw_ostream &OS) const override;
   std::error_code convertToErrorCode() const override;
   bool Matches(PyObject *exc) const;
-  std::string ReadBacktrace() const;
+  std::string ReadBacktrace(bool recursing = false) const;
 };
 
 // This extracts the underlying T out of an Expected<T> and returns it.
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.cpp
index 227be229cf6..3eee5218414 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.cpp
@@ -1165,19 +1165,17 @@ Status ScriptInterpreterPythonImpl::ExecuteMultipleLines(
 
   Expected<PythonObject> return_value =
       runStringMultiLine(in_string, globals, locals);
+
   if (!return_value) {
-    Status error;
-    llvm::handleAllErrors(
-        return_value.takeError(),
-        [&](PythonException &E) {
-          error.SetErrorString(E.ReadBacktrace());
+    llvm::Error error =
+        llvm::handleErrors(return_value.takeError(), [&](PythonException &E) {
+          llvm::Error error = llvm::createStringError(
+              llvm::inconvertibleErrorCode(), E.ReadBacktrace());
           if (!options.GetMaskoutErrors())
             E.Restore();
-        },
-        [&](const llvm::ErrorInfoBase &E) {
-          error.SetErrorString(E.message());
+          return error;
         });
-    return error;
+    return Status(std::move(error));
   }
 
   return Status();
@@ -1974,19 +1972,22 @@ StructuredData::DictionarySP ScriptInterpreterPythonImpl::GetDynamicSettings(
   if (!generic)
     return StructuredData::DictionarySP();
 
-  PythonObject reply_pyobj;
   Locker py_lock(this,
                  Locker::AcquireLock | Locker::InitSession | Locker::NoSTDIN);
   TargetSP target_sp(target->shared_from_this());
 
   auto setting = (PyObject *)LLDBSWIGPython_GetDynamicSetting(
       generic->GetValue(), setting_name, target_sp);
-  if (setting)
-    reply_pyobj = Take<PythonObject>(setting);
-  else
-    reply_pyobj.Reset();
 
-  PythonDictionary py_dict(PyRefType::Borrowed, reply_pyobj.get());
+  if (!setting)
+    return StructuredData::DictionarySP();
+
+  PythonDictionary py_dict =
+      unwrapIgnoringErrors(As<PythonDictionary>(Take<PythonObject>(setting)));
+
+  if (!py_dict)
+    return StructuredData::DictionarySP();
+
   return py_dict.CreateStructuredDictionary();
 }
 
diff --git a/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp b/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
index 4cf4fd13d9f..4e06b5331de 100644
--- a/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
+++ b/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
@@ -774,6 +774,23 @@ bar_unbound = Foo.bar
 #endif
 }
 
+TEST_F(PythonDataObjectsTest, TestScript) {
+
+  static const char script[] = R"(
+def factorial(n):
+  if n > 1:
+    return n * factorial(n-1)
+  else:
+    return 1;
+)";
+
+  PythonScript factorial(script, "factorial");
+  Expected<long long> r = As<long long>(factorial(5ll));
+  bool ok = (bool)r;
+  ASSERT_TRUE(ok);
+  EXPECT_EQ(r.get(), 120);
+}
+
 TEST_F(PythonDataObjectsTest, TestExceptions) {
 
   static const char script[] = R"(
