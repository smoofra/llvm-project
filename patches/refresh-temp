Bottom: c9d48d40e7da076269ea99a43eeb2bbd8a556331
Top:    a92e503eadbf1dbaa7fc547b22d7282ed18719fa
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-20 13:02:28 -0700

Refresh of no-more-reset

---
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index 3311cf9259f..cc8e4f94093 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -825,7 +825,7 @@ static const char get_arg_info_script[] = R"(
 from inspect import signature, Parameter, ismethod
 from collections import namedtuple
 ArgInfo = namedtuple('ArgInfo', ['count', 'has_varargs', 'is_bound_method'])
-def get_arg_info(f):
+def main(f):
     count = 0
     varargs = False
     for parameter in signature(f).parameters.values():
@@ -841,7 +841,6 @@ def get_arg_info(f):
         else:
             raise Exception(f'unknown parameter kind: {kind}')
     return ArgInfo(count, varargs, ismethod(f))
-_function_ = get_arg_info
 )";
 #endif
 
@@ -1048,14 +1047,13 @@ if sys.version_info.major < 3:
   from StringIO import StringIO
 else:
   from io import StringIO
-def read_exception(exc_type, exc_value, tb):
+def main(exc_type, exc_value, tb):
   f = StringIO()
   print_exception(exc_type, exc_value, tb, file=f)
   return f.getvalue()
-_function_ = read_exception  
 )";
 
-std::string PythonException::ReadBacktrace(bool recursing) const {
+std::string PythonException::ReadBacktraceRecursive(int limit) const {
 
   if (!m_traceback)
     return toCString();
@@ -1070,13 +1068,13 @@ std::string PythonException::ReadBacktrace(bool recursing) const {
     Twine message =
         Twine(toCString()) + "\n" +
         "Traceback unavailble, an error occurred while reading it:\n";
-    if (recursing)
+    if (limit > 0)
       return (message + llvm::toString(backtrace.takeError())).str();
 
     std::string backtrace2;
     Error error =
         llvm::handleErrors(backtrace.takeError(), [&](PythonException &E) {
-          backtrace2 = E.ReadBacktrace(true);
+          backtrace2 = E.ReadBacktraceRecursive(limit - 1);
         });
     if (error)
       backtrace2 = llvm::toString(std::move(error));
@@ -1532,15 +1530,14 @@ Error PythonScript::Init() {
 
   PythonDictionary globals(PyInitialValue::Empty);
   auto builtins = PythonModule::BuiltinsModule();
-  Error error = globals.SetItem("__builtins__", builtins);
-  if (error)
+  if (Error error = globals.SetItem("__builtins__", builtins))
     return error;
   PyObject *o =
       PyRun_String(script, Py_file_input, globals.get(), globals.get());
   if (!o)
     return exception();
   Take<PythonObject>(o);
-  auto f = As<PythonCallable>(globals.GetItem("_function_"));
+  auto f = As<PythonCallable>(globals.GetItem("main"));
   if (!f)
     return f.takeError();
   function = std::move(f.get());
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
index 5c8acec229f..cb0bf8eb330 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h
@@ -688,7 +688,8 @@ public:
   void log(llvm::raw_ostream &OS) const override;
   std::error_code convertToErrorCode() const override;
   bool Matches(PyObject *exc) const;
-  std::string ReadBacktrace(bool recursing = false) const;
+  std::string ReadBacktraceRecursive(int limit = 1) const;
+  std::string ReadBacktrace() const { return ReadBacktraceRecursive(); };
 };
 
 // This extracts the underlying T out of an Expected<T> and returns it.
@@ -748,9 +749,8 @@ llvm::Expected<PythonObject> runStringMultiLine(const llvm::Twine &string,
 // Example:
 //
 // const char script[] = R"(
-// def foo(x, y):
+// def main(x, y):
 //    ....
-// _function_ = foo
 // )";
 //
 // Expected<PythonObject> cpp_foo_wrapper(PythonObject x, PythonObject y) {
@@ -769,9 +769,8 @@ public:
 
   template <typename... Args>
   llvm::Expected<PythonObject> operator()(Args &&... args) {
-    llvm::Error e = Init();
-    if (e)
-      return std::move(e);
+    if (llvm::Error error = Init())
+      return std::move(error);
     return function.Call(std::forward<Args>(args)...);
   }
 };
diff --git a/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp b/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
index bacc09c3b9c..06bec82f0f8 100644
--- a/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
+++ b/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp
@@ -783,7 +783,7 @@ def factorial(n):
     return n * factorial(n-1)
   else:
     return 1;
-_function_ = factorial
+main = factorial
 )";
 
   PythonScript factorial(script);
@@ -802,24 +802,18 @@ def bar():
   return baz()
 def baz():
   return 1 / 0
-_function_ = foo
+main = foo
 )";
 
   PythonScript foo(script);
-  Expected<PythonObject> r = foo();
 
-  bool failed = !r;
-  ASSERT_TRUE(failed);
-
-  std::string backtrace;
-  llvm::handleAllErrors(r.takeError(), [&](const PythonException &E) {
-    backtrace = E.ReadBacktrace();
-  });
-
-  EXPECT_NE(backtrace.find("line 3, in foo"), std::string::npos);
-  EXPECT_NE(backtrace.find("line 5, in bar"), std::string::npos);
-  EXPECT_NE(backtrace.find("line 7, in baz"), std::string::npos);
-  EXPECT_NE(backtrace.find("ZeroDivisionError"), std::string::npos);
+  EXPECT_THAT_EXPECTED(foo(),
+                       llvm::Failed<PythonException>(testing::Property(
+                           &PythonException::ReadBacktrace,
+                           testing::ContainsRegex("line 3, in foo..*"
+                                                  "line 5, in bar.*"
+                                                  "line 7, in baz.*"
+                                                  "ZeroDivisionError"))));
 }
 
 TEST_F(PythonDataObjectsTest, TestRun) {
