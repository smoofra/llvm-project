Bottom: c15fd32b31beab089b75db8ffd3adcfb788c5c73
Top:    4c5821cdf3ef4483a569a1affb2118ccbbfcd140
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-03 12:16:33 -0700

Refresh of allow-arbitrary-python-streams

---
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index 2a5f831b335..7cbca083abe 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -1194,41 +1194,6 @@ public:
 };
 }
 
-llvm::Expected<FileSP> PythonFile::ConvertToFile(bool borrowed) {
-  if (!IsValid())
-    return llvm::createStringError(llvm::inconvertibleErrorCode(),
-                                   "invalid PythonFile");
-
-  int fd = PyObject_AsFileDescriptor(m_py_obj);
-  if (fd < 0) {
-    PyErr_Clear();
-    return ConvertToFileForcingUseOfScriptingIOMethods(borrowed);
-  }
-  auto options = GetOptionsForPyObject(*this);
-  if (!options)
-    return options.takeError();
-
-  // LLDB and python will not share I/O buffers.  We should probably
-  // flush the python buffers now.
-  Take<PythonObject>(PyObject_CallMethod(m_py_obj, "flush", "()"));
-  if (PyErr_Occurred())
-    return llvm::make_error<PythonException>("Flush");
-
-  FileSP file_sp;
-  if (borrowed) {
-    // In this case we we don't need to retain the python
-    // object at all.
-    file_sp = std::make_shared<NativeFile>(fd, options.get(), false);
-  } else {
-    file_sp = std::static_pointer_cast<File>(
-        std::make_shared<SimplePythonFile>(*this, borrowed, fd, options.get()));
-  }
-  if (!file_sp->IsValid())
-    return llvm::createStringError(llvm::inconvertibleErrorCode(),
-                                   "invalid File");
-
-  return file_sp;
-}
 
 #if PY_MAJOR_VERSION >= 3
 
@@ -1419,6 +1384,42 @@ public:
 
 #endif
 
+llvm::Expected<FileSP> PythonFile::ConvertToFile(bool borrowed) {
+  if (!IsValid())
+    return llvm::createStringError(llvm::inconvertibleErrorCode(),
+                                   "invalid PythonFile");
+
+  int fd = PyObject_AsFileDescriptor(m_py_obj);
+  if (fd < 0) {
+    PyErr_Clear();
+    return ConvertToFileForcingUseOfScriptingIOMethods(borrowed);
+  }
+  auto options = GetOptionsForPyObject(*this);
+  if (!options)
+    return options.takeError();
+
+  // LLDB and python will not share I/O buffers.  We should probably
+  // flush the python buffers now.
+  Take<PythonObject>(PyObject_CallMethod(m_py_obj, "flush", "()"));
+  if (PyErr_Occurred())
+    return llvm::make_error<PythonException>("Flush");
+
+  FileSP file_sp;
+  if (borrowed) {
+    // In this case we we don't need to retain the python
+    // object at all.
+    file_sp = std::make_shared<NativeFile>(fd, options.get(), false);
+  } else {
+    file_sp = std::static_pointer_cast<File>(
+        std::make_shared<SimplePythonFile>(*this, borrowed, fd, options.get()));
+  }
+  if (!file_sp->IsValid())
+    return llvm::createStringError(llvm::inconvertibleErrorCode(),
+                                   "invalid File");
+
+  return file_sp;
+}
+
 llvm::Expected<FileSP> PythonFile::ConvertToFileForcingUseOfScriptingIOMethods(
     bool borrowed) {
