Bottom: ee06322589071cba01ebb81d303cb8d7bc281b94
Top:    a4ba6a71612eb49aeb2ad7c0cb9f1696dfddca5e
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-10 17:49:02 -0700

Refresh of fix-getfile

---
diff --git a/lldb/include/lldb/Host/File.h b/lldb/include/lldb/Host/File.h
index 76f3d45dd69..5032b2207c6 100644
--- a/lldb/include/lldb/Host/File.h
+++ b/lldb/include/lldb/Host/File.h
@@ -301,12 +301,6 @@ public:
   ///     format string \a format.
   virtual size_t PrintfVarArg(const char *format, va_list args);
 
-  /// If this file is a wrapper for a python file object, return it.
-  ///
-  /// \return
-  ///    The PyObject* that this File wraps, or NULL.
-  virtual void *GetPythonObject() const;
-
   /// Return the OpenOptions for this file.
   ///
   /// Some options like eOpenOptionDontFollowSymlinks only make
@@ -319,6 +313,12 @@ public:
   ///    OpenOptions flags for this file, or 0 if unknown.
   virtual llvm::Expected<OpenOptions> GetOptions() const;
 
+  static char ID;
+
+  virtual bool isA(const void *classID) const { return classID == &ID; }
+
+  static bool classof(const File *file) { return file->isA(&ID); }
+
   llvm::Expected<const char *> GetOpenMode() const {
     auto opts = GetOptions();
     if (!opts)
@@ -423,6 +423,11 @@ public:
   size_t PrintfVarArg(const char *format, va_list args) override;
   llvm::Expected<OpenOptions> GetOptions() const override;
 
+  static char ID;
+  virtual bool isA(const void *classID) const override {
+    return classID == &ID || File::isA(classID);
+  }
+  static bool classof(const File *file) { return file->isA(&ID); }
 
 protected:
   bool DescriptorIsValid() const {
diff --git a/lldb/scripts/interface/SBFile.i b/lldb/scripts/interface/SBFile.i
index ea3389e5924..9635bf5a218 100644
--- a/lldb/scripts/interface/SBFile.i
+++ b/lldb/scripts/interface/SBFile.i
@@ -78,7 +78,21 @@ public:
 
     SBError Close();
 
-    %feature("docstring", "convert this SBFile into a python io.IOBase file object");
+    %feature("docstring", "
+    Convert this SBFile into a python io.IOBase file object.
+
+    If the SBFile is itself a wrapper around a python file object,
+    this will return that original object.
+
+    The file returned from here should be considered borrowed,
+    in the sense that you may read and write to it, and flush it,
+    etc, but you should not close it.   If you want to close the
+    SBFile, call SBFile.Close().
+
+    If there is no underlying python file to unwrap, GetFile will
+    use the file descirptor, if availble to create a new python
+    file object using `open(fd, mode=..., closefd=False)`
+    ");
     FileSP GetFile();
 };
 
diff --git a/lldb/source/Host/common/File.cpp b/lldb/source/Host/common/File.cpp
index 3c8e0c6347f..c38fbf13965 100644
--- a/lldb/source/Host/common/File.cpp
+++ b/lldb/source/Host/common/File.cpp
@@ -39,6 +39,8 @@ using namespace lldb;
 using namespace lldb_private;
 using llvm::Expected;
 
+char File::ID = 0;
+char NativeFile::ID = 0;
 
 Expected<const char *>
 File::GetStreamOpenModeFromOptions(File::OpenOptions options) {
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index 665199cd316..8f0a717dc8c 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -22,6 +22,7 @@
 #include "lldb/Utility/Stream.h"
 
 #include "llvm/ADT/StringSwitch.h"
+#include "llvm/Support/Casting.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/Errno.h"
 
@@ -1061,37 +1062,6 @@ void PythonFile::Reset(PyRefType type, PyObject *py_obj) {
   PythonObject::Reset(PyRefType::Borrowed, result.get());
 }
 
-Expected<PythonFile> PythonFile::FromFile(File &file, const char *mode) {
-  if (!file.IsValid())
-    return llvm::createStringError(llvm::inconvertibleErrorCode(),
-                                   "invalid file");
-
-  PyObject *file_obj = (PyObject *)file.GetPythonObject();
-  if (file_obj)
-    return Retain<PythonFile>(file_obj);
-
-  if (!mode)
-    mode = file.GetOpenMode();
-  if (!mode)
-    return llvm::createStringError(llvm::inconvertibleErrorCode(),
-                                   "can't determine open mode for file");
-
-#if PY_MAJOR_VERSION >= 3
-  file_obj = PyFile_FromFd(file.GetDescriptor(), nullptr, mode, -1, nullptr,
-                           "ignore", nullptr, 0);
-#else
-  // Read through the Python source, doesn't seem to modify these strings
-  char *cmode = const_cast<char *>(mode);
-  file_obj =
-      PyFile_FromFile(file.GetStream(), const_cast<char *>(""), cmode, nullptr);
-#endif
-
-  if (!file_obj)
-    return exception();
-
-  return Take<PythonFile>(file_obj);
-}
-
 namespace {
 class GIL {
 public:
@@ -1229,7 +1199,12 @@ public:
     return base_error;
   };
 
-  void *GetPythonObject() const override { return m_py_obj.get(); }
+  PyObject *GetPythonObject() const {
+    assert(m_py_obj.IsValid());
+    return m_py_obj.get();
+  }
+
+  static bool classof(const File *file) = delete;
 
 protected:
   PythonFile m_py_obj;
@@ -1245,7 +1220,14 @@ public:
   SimplePythonFile(const PythonFile &file, bool borrowed, int fd,
                    File::OpenOptions options)
       : OwnedPythonFile(file, borrowed, fd, options, false) {}
+
+  static char ID;
+  bool isA(const void *classID) const override {
+    return classID == &ID || NativeFile::isA(classID);
+  }
+  static bool classof(const File *file) { return file->isA(&ID); }
 };
+char SimplePythonFile::ID = 0;
 } // namespace
 
 #if PY_MAJOR_VERSION >= 3
@@ -1319,8 +1301,13 @@ public:
     return GetOptionsForPyObject(m_py_obj);
   }
 
+  static char ID;
+  bool isA(const void *classID) const override {
+    return classID == &ID || File::isA(classID);
   }
+  static bool classof(const File *file) { return file->isA(&ID); }
 };
+char PythonIOFile::ID = 0;
 } // namespace
 
 namespace {
@@ -1541,4 +1528,40 @@ PythonFile::ConvertToFileForcingUseOfScriptingIOMethods(bool borrowed) {
 #endif
 }
 
+Expected<PythonFile> PythonFile::FromFile(File &file, const char *mode) {
+  if (!file.IsValid())
+    return llvm::createStringError(llvm::inconvertibleErrorCode(),
+                                   "invalid file");
+
+  auto *simple = llvm::dyn_cast<SimplePythonFile>(&file);
+  if (simple)
+    return Retain<PythonFile>(simple->GetPythonObject());
+  auto *pythonio = llvm::dyn_cast<PythonIOFile>(&file);
+  if (pythonio)
+    return Retain<PythonFile>(pythonio->GetPythonObject());
+
+  if (!mode) {
+    auto m = file.GetOpenMode();
+    if (!m)
+      return m.takeError();
+    mode = m.get();
+  }
+
+  PyObject *file_obj;
+#if PY_MAJOR_VERSION >= 3
+  file_obj = PyFile_FromFd(file.GetDescriptor(), nullptr, mode, -1, nullptr,
+                           "ignore", nullptr, 0);
+#else
+  // Read through the Python source, doesn't seem to modify these strings
+  char *cmode = const_cast<char *>(mode);
+  file_obj =
+      PyFile_FromFile(file.GetStream(), const_cast<char *>(""), cmode, nullptr);
+#endif
+
+  if (!file_obj)
+    return exception();
+
+  return Take<PythonFile>(file_obj);
+}
+
 #endif
