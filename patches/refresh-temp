Bottom: cf66416703f3bb1a4ca7fff56b86a2b4ef324710
Top:    86cae19688ecc35b91d3d739d6634b32b5e64313
Author: Lawrence D'Anna <lawrence_danna@apple.com>
Date:   2019-10-03 10:03:20 -0700

Refresh of allow-arbitrary-python-streams

---
diff --git a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
index 326e2c91185..84171ba4270 100644
--- a/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
+++ b/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp
@@ -1038,7 +1038,10 @@ FileUP PythonFile::GetUnderlyingFile() const {
 
 class GIL {
 public:
-  GIL() { m_state = PyGILState_Ensure(); }
+  GIL() {
+    m_state = PyGILState_Ensure();
+    assert(!PyErr_Occurred());
+  }
   ~GIL() { PyGILState_Release(m_state); }
 
 protected:
@@ -1100,11 +1103,12 @@ llvm::Expected<uint32_t> GetOptionsForPyObject(PythonObject & obj) {
 #if PY_MAJOR_VERSION >= 3
   auto readable =
       Take<PythonObject>(PyObject_CallMethod(obj.get(), "readable", "()"));
+  if (PyErr_Occurred())
+    return llvm::make_error<PythonException>("ConvertToFile");
   auto writable =
       Take<PythonObject>(PyObject_CallMethod(obj.get(), "writable", "()"));
-  if (PyErr_Occurred()) {
+  if (PyErr_Occurred())
     return llvm::make_error<PythonException>("ConvertToFile");
-  }
   if (PyObject_IsTrue(readable.get()))
     options |= File::eOpenOptionRead;
   if (PyObject_IsTrue(writable.get()))
@@ -1189,6 +1193,7 @@ llvm::Expected<FileSP> PythonFile::ConvertToFile(bool borrowed) {
 
   int fd = PyObject_AsFileDescriptor(m_py_obj);
   if (fd < 0) {
+    PyErr_Clear();
     return ConvertToFileForcingUseOfScriptingIOMethods(borrowed);
   }
   auto options = GetOptionsForPyObject(*this);
@@ -1221,6 +1226,7 @@ llvm::Expected<FileSP> PythonFile::ConvertToFile(bool borrowed) {
 
 class PythonBuffer {
 public:
+  // you must check PyErr_Occurred() after calling this constructor.
   PythonBuffer(PythonObject &obj, int flags = PyBUF_SIMPLE) : m_buffer({}) {
     PyObject_GetBuffer(obj.get(), &m_buffer, flags);
   }
@@ -1265,7 +1271,6 @@ public:
 
   Status Flush() override {
     GIL takeGIL;
-    PyErr_Clear();
     Take<PythonObject>(PyObject_CallMethod(m_py_obj, "flush", "()"));
     Status error;
     if (PyErr_Occurred())
@@ -1381,6 +1386,8 @@ public:
       return Status(llvm::make_error<PythonException>("Read"));
     if (!PyUnicode_Check(pystring.get()))
       return Status("read() didn't return a str");
+    if (PyErr_Occurred())
+      return Status(llvm::make_error<PythonException>("Read"));
     Py_ssize_t size;
     const char *utf8 = PyUnicode_AsUTF8AndSize(pystring.get(), &size);
     if (!utf8 || PyErr_Occurred())
@@ -1396,6 +1403,9 @@ public:
 
 llvm::Expected<FileSP> PythonFile::ConvertToFileForcingUseOfScriptingIOMethods(
     bool borrowed) {
+
+  assert(!PyErr_Occurred());
+
   if (!IsValid())
     return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                    "invalid PythonFile");
@@ -1419,15 +1429,26 @@ llvm::Expected<FileSP> PythonFile::ConvertToFileForcingUseOfScriptingIOMethods(
   auto rawIOBase = io_dict.GetItemForKey(PythonString("BufferedIOBase"));
   auto bufferedIOBase = io_dict.GetItemForKey(PythonString("RawIOBase"));
 
+  // python interpreter badly janked if we can't get those.
+  assert(!PyErr_Occurred());
+
   FileSP file_sp;
   if (PyObject_IsInstance(m_py_obj, textIOBase.get())) {
     file_sp = std::static_pointer_cast<File>(
         std::make_shared<TextPythonFile>(fd, *this, borrowed));
-  } else if (PyObject_IsInstance(m_py_obj, rawIOBase.get()) ||
-             PyObject_IsInstance(m_py_obj, bufferedIOBase.get())) {
+  }
+  if (PyErr_Occurred())
+    return llvm::make_error<PythonException>("Convert");
+
+  if (!file_sp && (PyObject_IsInstance(m_py_obj, rawIOBase.get()) ||
+             PyObject_IsInstance(m_py_obj, bufferedIOBase.get()))) {
     file_sp = std::static_pointer_cast<File>(
         std::make_shared<BinaryPythonFile>(fd, *this, borrowed));
-  } else
+  }
+  if (PyErr_Occurred())
+    return llvm::make_error<PythonException>("Convert");
+
+  if (!file_sp)
     return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                    "python file is neither text nor binary");
